ffi-lib: cstyles/zip.c

ffi-types:
    pZip:
        c-style: zip_t *
        type-to-rex: (value){(unknownPtr)($param)}
        rex-to-type: (zip_t *)($param.basicValue.unknown)
    :pZip
    cStr:
        c-style: cStr
        type-to-rex: (value){rex::string2wstring($param.str)), rex::stringMethods::getMethodsCxt()}
        rex-to-type: (cStr)(rex::wstring2string($param.getStr()))
    :cStr
    i32:
        c-style: int
        type-to-rex: (value){(vint)($param)}
        rex-to-type: (int)($param.getInt())
    :i32
    i64:
        c-style: int64_t
        type-to-rex: (value){(vint)($param)}
        rex-to-type: (int64_t)($param.getInt())
    :i64
    vBytesBuf:
        c-style: void *
        type-to-rex: (value){(unknownPtr)(nullptr)}
        rex-to-type: (void *)($param.getBytes().data())
    :vBytesBuf
:end-ffi-types

ffi-exports:
    name: open
    symbol: zip_open
    params: cStr,i32,i32
    result: pZip

    name: close
    symbol: zip_close
    params: pZip
    result: none

    name: entryOpen
    symbol: zip_entry_open
    params: pZip,cStr
    result: i32

    name: entryClose
    symbol: zip_entry_close
    params: pZip
    result: i32

    name: entryWrite
    symbol: zip_entry_write
    params: pZip,vBytesBuf,i64
    result: i32
:end-ffi-exports

ffi-helpers:
struct cStr {
    std::string str{};
    cStr(const std::string &str) : str(str) {}

    operator char*() {
        return str.data();
    }
};
:end-ffi-helpers